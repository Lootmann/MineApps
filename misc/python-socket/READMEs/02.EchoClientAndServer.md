# Echo Client and Server

Now that you've gotten an overview of the socket API and how the client
and server communicate, you're ready to create your first client and server.
You'll begin with a simple implementation. The server will simply echo
whatever it reveives back to the client.

> socket API の概要を掴んだ, そして Client と Server の通信方法を知りました
> Client and Server を作る準備ができた
> まずは簡単な実装から サーバーはクライアントから送信されたもの何でも
> echo します

Okay, so what exactly is happening in the API call?

`socket.socket()` creates a socket object that supports the `context manager type`,
so you can use it in a `with statement`. There's no need to call `s.close()`:

> context manager type を 利用できる socket オブジェクトを作る socket.socket()
> こいつと with を利用すると socket の close は 必要ない

```python
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
  pass
```

The arguments passed to `socket()` are `constants` used to specify the
`address family` and socket `type.AF_INET` is the Internet address family for
`IPv4.SOCK_STREAM` is the socket type for `TCP`, the protocol that will be used to
transport messages in the network.

The `.bind()` method is used to associate the socket with a specific network
interface and port number.

> Address family: ネックアドレスの種類 AF_INET(IPv4), AF_INET6(IPv6) など
> socket type を指定する SOCK_STREAM は TCP 用のもの
> .bind() は 特定のネットワークと port をソケットに関連付けるメソッド

The values passed to `.bind()` depend on the `address family` of the socket.
In this example, you're using `socket.AF_INET` (IPv4).
So it expects a two-tuple: `(host, port)`

> .bind() メソッドに渡す値は address family によって変わります
> socket.AF_INET つまり IPv4 を利用するときには (host: str, port: int)
> を渡す必要があります

`host` can be a hostname, IP address, or empty string. If an IP address is used,
host should be an IPv4-formatted address string.
The IP address `127.0.0.1` is the standard IPv4 address for the loopback interface,
so only processes on the host will be able to connect to the server.
If you pass an empty string, the server will accept connections on all available
IPv4 interfaces.

> (host, port) について
> host は hostname: str, IP address: str, or "" です
> IP address 形式を用いるときには xxx.xxx.xxx.xxx の文字列である必要がある
> 127.0.0.1 は IPv4 の loopback interface を利用するときに ip address です
> empty string "" を渡すと サーバーはあらゆる ipv4 interface から利用できるように
> なります

`port` represents the TCP port number to accept connections on from clients.
It should be an integer from 1 to 65535, as 0 is reserved.
Some systems may require superuser privileges if the port number is less than 1024.

> port は クライアントからの接続を許可する TCP のポート番号を表している
> 1 - 65535 までのどこかの値である必要があります
> 1 - 1024 までは大概予約ポート番号なので 利用しないほうが良い
> (superuser の権限が必要になる OS などの環境が存在する)

Here’s a note on using hostnames with .bind():

If you use a hostname in the host portion of IPv4/v6 socket address,
the program may show a non-deterministic behavior, as Python uses the first address
returned from the DNS resolution.
The socket address will be resolved differently into an actual IPv4/v6 address,
depending on the results from DNS resolution and/or the host configuration.
For deterministic behavior use a numeric address in host portion.

> .bind() に hostnames を使ったときの注意事項
>
> IPv4/v6 のソケットアドレスに hostname を利用した場合は
> プログラムがどういう振る舞いをするのかは定義されておらず
> Python であれば　 DNS 解決から最初に戻ってきた IPAddress を利用することになります
> socket address は 実際の IPv4/v6 アドレスとは異なった解決をされ
> DNS 解決と host configuration の中によって依存しています
> 数字で IP アドレス指定した方がいいよ

You’ll learn more about this later, in Using Hostnames.
For now, just understand that when using a hostname, you could see different
results depending on what’s returned from the name resolution process.
These results could be anything. The first time you run your application,
you might get the address 10.1.2.3. The next time, you get a different address,
192.168.0.1. The third time, you could get 172.16.7.8, and so on.

> 数字で IP アドレス指定しほうがいいよ

In the server example, `.listen()` enables a server to accept connections.
It makes the server a “listening” socket:

> .listen() を使用して サーバーが通信をすることを可能にします
> server を listening 状態にする

```python
with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.bind((HOST, PORT))
    s.listen()
    conn, addr = s.accept()
```
